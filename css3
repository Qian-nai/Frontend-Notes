CSS3的现状
    浏览器支持程度不够好，有些需要添加私有前缀
    移动端支持优于PC端
    不断改进中
    应用相对广泛
    #应对的策略：渐进增强
    （1）坚持渐进增强的原则：让低版本浏览器能正常访问页面，高版本的浏览器用户体验更好。【重要】
    比如说，同样是一个头像，可能在低版本的浏览器中，头像方的；在高版本的浏览器中，头像是圆的。
    （2）考虑用户群体。
    （3）遵照产品的方案。

CSS3 选择器
    属性选择器
        属性选择器的标志性符号是 []。
        匹配含义：
        ^：开头  $：结尾  *：包含
        格式：
        E[title] 选中页面的E元素，并且E存在 title 属性即可。
        E[title="abc"]选中页面的E元素，并且E需要带有title属性，且属性值完全等于abc。
        E[attr~=val] 选择具有 att 属性且属性值为：用空格分隔的字词列表，其中一个等于 val 的E元素。
        E[attr|=val] 表示要么是一个单独的属性值，要么这个属性值是以“-”分隔的。
        E[title^="abc"] 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 开头。
        E[title$="abc"] 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 结尾。
        E[title*="abc"] 选中页面的E元素，并且E需要带有 title 属性,属性值任意位置包含abc。
        比如说，我们用属性选择器去匹配标签的className，是非常方便的。

    结构伪类选择器
        伪类选择器的标志性符号是 :。
        CSS中有一些伪类选择器，比如:link、:visited、:hover、:active、:focus。
        CSS3又新增了其它的伪类选择器。这一小段，我们来学习CSS3中的结构伪类选择器：即通过结构来进行筛选。
        1、格式：（第一部分）（重要）
        E:first-child 匹配父元素的第一个子元素E。
        E:last-child 匹配父元素的最后一个子元素E。
        E:nth-child(n) 匹配父元素的第n个子元素E。注意，盒子的编号是从1开始算起，不是从0开始算起。
        E:nth-child(odd) 匹配奇数
        E:nth-child(even) 匹配偶数
        E:nth-last-child(n) 匹配父元素的倒数第n个子元素E。
        理解：
        （1）这里我们要好好理解父元素的含义，它指的是：以 E 元素的父元素为参考。
        （2）注意：以上选择器中所选到的元素的类型，必须是指定的类型E，如果选不中，则无效。这个要好好理解，具体可以看CSS参考手册中的E:nth-child(n)的示例。我们可以理解成：先根据选择器找到选中的全部位置，如果发现某个位置不是类型E，则该位置失效。
        （3）另外，E:nth-child(n)这个属性也很有意思。比如，针对下面这样一组标签：
                <ul>
                    <li>1</li>
                    <li>2</li>
                    <li>3</li>
                    <li>4</li>
                    <li>5</li>
                    <li>6</li>
                    <li>7</li>
                    <li>8</li>
                    <li>9</li>
                    <li>10</li>
                </ul>
            上方代码中：
            如果选择器写成li:nth-child(2)，则表示第2个 li。
            如果选择器写成li:nth-child(n)，则表示所有的li。因为此时的 n 表示 0,1,2,3,4,5,6,7,8.....（当n小于1时无效，因为n = 0 也是不会选中的）
            如果选择器写成li:nth-child(2n)，则表示所有的第偶数个 li。
            如果选择器写成li:nth-child(2n+1)，则表示所有的第奇数个 li。
            如果选择器写成li:nth-child(-n+5)，则表示前5个 li。
            如果选择器写成li:nth-last-child(-n+5)，则表示最后5个 li。
            如果选择器写成li:nth-child(7n)，则表示选中7的倍数。。
            上面列举的选择器中，我们只要记住： n 表示 0,1,2,3,4,5,6,7,8.....就很容易明白了。
            2、格式：（第二部分）
            E:first-of-type 匹配同类型中的第一个同级兄弟元素E。
            E:last-of-type 匹配同类型中的最后一个同级兄弟元素E。
            E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E。
            E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E。
            既然上面这几个选择器带有type，我们可以这样理解：先在同级里找到所有的E类型，然后根据 n 进行匹配。
            3、格式：（第三部分）
            E:empty 匹配没有任何子节点（包括空格等text节点）的元素E。
            E:target 匹配相关URL指向的E元素。要配合锚点使用。

    伪元素选择器
        伪元素选择器的标志性符号是 ::。
        1、格式：（第一部分）
        E::before 设置在 元素E 前面（依据对象树的逻辑结构）的内容，配合content属性一起使用。
        E::after 设置在 元素E 后面（依据对象树的逻辑结构）的内容，配合content属性一起使用。
        E:after、E:before在旧版本里是伪类，在 CSS3 这个新版本里是伪元素。新版本里，E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待，这样做的目的是用来做兼容处理。
        通过伪元素选择器，就可以添加出类似于span标签的效果（记得要结合 content 属性使用）。
        通过这两个属性添加的伪元素，是行内元素，需要转换成块元素才能设置宽高。
        2、格式：（第二部分）
        E::first-letter 设置元素 E 里面的第一个字符的样式。
        E::first-line 设置元素 E 里面的第一行的样式。
        E::selection 设置元素 E 里面被鼠标选中的区域的样式（一般设置颜色和背景色）。

CSS3属性详解
    文本
        #text-shadow：设置文本的阴影
        格式举例：
            text-shadow: 20px 27px 22px pink;
        参数解释：水平位移 垂直位移 模糊程度 阴影颜色。
        /* text-shadow 可以设置多个阴影，每个阴影之间使用逗号隔开*/
        .tu {
            text-shadow: -1px -1px 1px #fff, 1px 1px 1px #000;
        }

        .ao {
            text-shadow: -1px -1px 1px #000, 1px 1px 1px #fff;
        }
        实现凹凸文字效果的方式比较简单，给左上角放黑色的阴影，右下角放白色的阴影，就达到了凹下去的效果。
    盒模型中的 box-sizing 属性
        我们在**之前的文章 (opens new window)**中专门讲过盒子模型。
        CSS3 对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。
        这就需要用到 box-sizing属性。它的属性值可以是：content-box、border-box。解释如下。
        外加模式：（css的默认方式）
            box-sizing: content-box;
        解释：此时设置的 width 和 height 是内容区域的宽高。盒子的实际宽度 = 设置的 width + padding + border。此时改变 padding 和 border 的大小，也不会改变内容的宽高，而是盒子的总宽高发生变化。
    处理兼容性问题：私有前缀
        通过网址http://caniuse.com/ (opens new window)可以查询CSS3各特性的支持程度。
        处理兼容性问题的常见方法：为属性添加私有前缀。
        如此方法不能解决，应尽量避免使用，无需刻意去处理CSS3的兼容性问题。
        私有前缀的举例：
        比如说，我想给指定的div设置下面这样一个属性：
            background: linear-gradient(left, green, yellow);
        上面这个属性的作用是：添加从左到右的线性渐变，颜色从绿色变为黄色。
        此时，我们可以为浏览器添加不同的私有前缀，属性就可以生效了。
        格式如下：
            -webkit-: 谷歌 苹果
            -moz-:火狐
            -ms-：IE
            -o-：欧朋
        格式举例如下：
            background: -webkit-linear-gradient(left, green, yellow);
            background: -moz-linear-gradient(left, green, yellow);
            background: -ms-linear-gradient(left, green, yellow);
            background: -o-linear-gradient(left, green, yellow);
            background: linear-gradient(left, green, yellow);
    边框
        边框的属性很多，其中边框圆角和边框阴影这两个属性，应用十分广泛，兼容性也相对较好，且符合渐进增强的原则，需要重点熟悉。
        
            #边框圆角：border-radius 属性
                边框的每个圆角，本质上是一个圆，圆有水平半径和垂直半径：如果二者相等，就是圆；如果二者不等， 就是椭圆。
                单个属性的写法：
                    border-top-left-radius: 60px 120px;        //参数解释：水平半径   垂直半径
                    border-top-right-radius: 60px 120px;
                    border-bottom-left-radius: 60px 120px;
                    border-bottom-right-radius: 60px 120px;
                复合写法：
                    border-radius: 60px/120px;             //参数：水平半径/垂直半径
                    border-radius: 20px 60px 100px 140px;  //从左上开始，顺时针赋值。如果当前角没有值，取对角的值
                    border-radius: 20px 60px;
                最简洁的写法：（四个角的半径都相同时）
                    border-radius: 60px;

            边框阴影：box-shadow 属性
                格式举例：
                    box-shadow: 水平偏移 垂直偏移 模糊程度 阴影大小 阴影颜色
                    box-shadow: 15px 21px 48px -2px #666;
                参数解释：
                水平偏移：正值向右 负值向左。
                垂直偏移：正值向下 负值向上。
                模糊程度：不能为负值。
                另外，后面还可以再加一个inset属性，表示内阴影。如果不写，则默认表示外阴影。例如：
	            box-shadow:3px 3px 3px 3px #666 inset;
                注意：设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局。
                我们还可以设置多重边框阴影，实现更好的效果，增强立体感。

            边框图片
                边框图片有以下属性：
                    /* 边框图片的路径*/
                    border-image-source: url("images/border.png");
                    /* 图片边框的裁剪*/
                    border-image-slice: 27;
                    /*图片边框的宽度*/
                    border-image-width: 27px;
                    /*边框图片的平铺*/
                    /* repeat :正常平铺 但是可能会显示不完整*/
                    /*round: 平铺 但是保证 图片完整*/
                    /*stretch: 拉伸显示*/
                    border-image-repeat: stretch;
                我们也可以写成一个综合属性：
                    border-image: url("images/border.png") 27/20px round;

CSS3属性详解：动画详解
    过渡：transition
        transition的中文含义是过渡。过渡是CSS3中具有颠覆性的一个特征，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。
        补间动画：自动完成从起始状态到终止状态的的过渡。不用管中间的状态。
        帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片。
        transition 包括以下属性：
        transition-property: all; 如果希望所有的属性都发生过渡，就使用all。
        transition-duration: 1s; 过渡的持续时间。
        transition-timing-function: linear; 运动曲线。属性值可以是：
        linear 线性
        ease 减速
        ease-in 加速
        ease-out 减速
        ease-in-out 先加速后减速
        transition-delay: 1s; 过渡延迟。多长时间后再执行这个过渡动画。
        上面的四个属性也可以写成综合属性：
            transition: 让哪些属性进行过度 过渡的持续时间 运动曲线 延迟时间;
            transition: all 3s linear 0s;
            如果设置 transition-property: width，意思是只让盒子的宽度在变化时进行过渡。
            如果设置 transition-property: all，意思是让盒子的所有属性（包括宽度、背景色等）在变化时都进行过渡。
    2D 转换
        转换是 CSS3 中具有颠覆性的一个特征，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式。
        转换再配合过渡和动画，可以取代大量早期只能靠 Flash 才可以实现的效果。
        在 CSS3 当中，通过 transform 转换来实现 2D 转换或者 3D 转换。
        2D转换包括：缩放、移动、旋转。
        我们依次来讲解。
            #1、缩放：scale
                格式：
                    transform: scale(x, y);
                    transform: scale(2, 0.5);
                参数解释： x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。
                取值：大于1表示放大，小于1表示缩小。不能为百分比。
            #2、移动：translate        
                格式：
                    transform: translate(水平位移, 垂直位移);
                    transform: translate(-50%, -50%);
                参数解释：
                参数为百分比，相对于自身移动。
                正值：向右和向下。 负值：向左和向上。如果只写一个值，则表示水平移动。
            #3、旋转：rotate
                格式：
                    transform: rotate(角度);
                    transform: rotate(45deg);
                参数解释：正值 顺时针；负值：逆时针。

3D 转换
    #1、旋转：rotateX、rotateY、rotateZ
    3D坐标系（左手坐标系）
    伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。拇指、食指和中指分别代表X、Y、Z轴的正方向，这样我们就建立了一个左手坐标系。
    浏览器的这个平面，是X轴、Y轴；垂直于浏览器的平面，是Z轴。
    旋转的方向：（左手法则）
    左手握住旋转轴，竖起拇指指向旋转轴的正方向，正向就是其余手指卷曲的方向。
    从上面这句话，我们也能看出：所有的3d旋转，对着正方向去看，都是顺时针旋转。
    格式：
        transform: rotateX(360deg);    //绕 X 轴旋转360度
        transform: rotateY(360deg);    //绕 Y 轴旋转360度
        transform: rotateZ(360deg);    //绕 Z 轴旋转360度
    #2、移动：translateX、translateY、translateZ
        格式：
            transform: translateX(100px);    //沿着 X 轴移动
            transform: translateY(360px);    //沿着 Y 轴移动
            transform: translateZ(360px);    //沿着 Z 轴移动
   # 3、透视：perspective
        电脑显示屏是一个 2D 平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。
        透视可以将一个2D平面，在转换的过程当中，呈现3D效果。但仅仅只是视觉呈现出 3d 效果，并不是正真的3d。
        格式有两种写法：
        作为一个属性，设置给父元素，作用于所有3D转换的子元素
        作为 transform 属性的一个值，做用于元素自身。
        格式举例：
        perspective: 500px;
    #4、3D呈现（transform-style）
        3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。属性值可以如下：
            transform-style: preserve-3d;     /* 让 子盒子 位于三维空间里 */
            transform-style: flat;            /* 让子盒子位于此元素所在的平面内（子盒子被扁平化） */

动画
动画是CSS3中具有颠覆性的特征，可通过设置多个节点 来精确控制一个或一组动画，常用来实现复杂的动画效果。

    #1、定义动画的步骤
        （1）通过@keyframes定义动画；
        （2）将这段动画通过百分比，分割成多个节点；然后各节点中分别定义各属性；
        （3）在指定元素里，通过 animation 属性调用动画。
        之前,我们在 js 中定义一个函数的时候，是先定义，再调用：
            js 定义函数：
                function fun(){ 函数体 }
            调用：
                fun();
        同样，我们在 CSS3 中定义动画的时候，也是先定义，再调用：
            定义动画：
                @keyframes 动画名{
                    from{ 初始状态 }
                    to{ 结束状态 }
                }
            调用：
            animation: 动画名称 持续时间；
        其中，animation属性的格式如下：
                    animation: 定义的动画名称 持续时间  执行次数  是否反向  运动曲线 延迟执行。(infinite 表示无限次)
                    animation: move1 1s  alternate linear 3;
                    animation: move2 4s;

    #2、动画属性
        我们刚刚在调用动画时，animation属性的格式如下：
        animation属性的格式如下：
                    animation: 定义的动画名称  持续时间  执行次数  是否反向  运动曲线 延迟执行。(infinite 表示无限次)
                    animation: move1 1s  alternate linear 3;
                    animation: move2 4s;
        可以看出，这里的 animation 是综合属性，接下来，我们把这个综合属性拆分看看。
        （1）动画名称：
            animation-name: move;
        （2）执行一次动画的持续时间：
            animation-duration: 4s;
        备注：上面两个属性，是必选项，且顺序固定。
        （3）动画的执行次数：
            animation-iteration-count: 1;       //iteration的含义表示迭代
        属性值infinite表示无数次。
        （3）动画的方向：
            animation-direction: alternate;
        属性值：normal 正常，alternate 反向。
        （4）动画延迟执行：
            animation-delay: 1s;
        （5）设置动画结束时，盒子的状态：
            animation-fill-mode: forwards;
        属性值： forwards：保持动画结束后的状态（默认）， backwards：动画结束后回到最初的状态。
        （6）运动曲线：
            animation-timing-function: ease-in;
        属性值可以是：linear ease-in-out steps()等。
        注意，如果把属性值写成**steps()，则表示动画不是连续执行**，而是间断地分成几步执行。我们接下来专门讲一下属性值 steps()。

CSS3属性：Flex布局图文详解
    CSS3中的 flex 属性，在布局方面做了非常大的改进，使得我们对多个元素之间的布局排列变得十分灵活，适应性非常强。其强大的伸缩性和自适应性，在网页开中可以发挥极大的作用。
    flex 初体验
        默认文档流中，在一个父容器里放置多个块级的子元素，那么，这些子元素会默认从上往下排列。
        在此基础之上，如果我给父容器仅仅加一个 display: flex属性，此时，这些子元素的布局会摇身一变：
        没错，子元素们会在水平方向上，从左至右排列，就是这么神奇。到此为止，你已经掌握了关于 flex 的一半的知识。
    flex 布局的优势
        1、flex 布局的子元素不会脱离文档流，很好地遵从了“流的特性”。
        但你如果用 float 来做布局，float 属性的元素会脱离文档流，而且会涉及到各种 BFC、清除浮动的问题。浮动相关的问题，比较麻烦，所以也成了面试必问的经典题目。但有了 flex 布局之后，这些问题都不存在的。
        2、flex 是一种现代的布局方式，是 W3C 第一次提供真正用于布局的 CSS 规范。 flex 提供了非常丰富的属性，非常灵活，让布局的实现更佳多样化，且方便易用。
        flex 唯一的缺点就在于，它不支持低版本的 IE 浏览器。

    flex 的兼容性问题
        flex 布局不支持 IE9 及以下的版本；IE10及以上也只是部分支持。如果你的页面不需要处理 IE浏览器的兼容性问题，则可以放心大胆地使用 flex 布局。
        但是，比如网易新闻、淘宝这样的大型网站，面对的是海量用户，即便使用低版本浏览器的用户比例很少，但绝对基数仍然是很庞大的。因此，这些网站为了兼容低版本的 IE 浏览器，暂时还不敢尝试使用 flex 布局。
        概念：弹性盒子、子元素

    在讲 flex 的知识点之前，我们事先约定两个概念：
        弹性盒子：指的是使用 display:flex 或 display:inline-flex 声明的父容器。
        子元素/弹性元素：指的是父容器里面的子元素们（父容器被声明为 flex 盒子的情况下）。
    #概念：主轴和侧轴
        在上面的“初体验”例子中，我们发现，弹性盒子里面的子元素们，默认是从左至右排列的，这个方向，代表的就是主轴的方向。
        在此，我们引入主轴和侧轴的概念。
            主轴：flex容器的主轴，默认是水平方向，从左向右。
            侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向，从上往下。
            PS：主轴和侧轴并不是固定不变的，可以通过 flex-direction 更换方向，我们在后面会讲到。