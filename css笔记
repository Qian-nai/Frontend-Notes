字体属性:
    font-size: 50px; 		/*字体大小*/
	line-height: 30px;      /*行高*/
	font-family: 幼圆,黑体; 	/*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/
	font-style: italic ;		/*italic表示斜体，normal表示不倾斜*/
	font-weight: bold/normal/数字;	/*粗细*/
	font-variant: small-caps;  /*小写变大写*/
    vertical-align: middle; /*指定行级元素的垂直对齐方式。*/
    font:12px/30px  "Times New Roman","Microsoft YaHei","SimSun"; /*简写：字体大小/行高 字体类型*/

文本属性:
    letter-spacing: 0.5cm ; 单个字母之间的间距
    word-spacing: 1cm; 单词之间的间距
    text-decoration: none; 字体修饰：none 去掉下划线、underline 下划线、line-through 中划线、overline 上划线
    color:red; 字体颜色
    text-align: center; 在当前容器中的对齐方式。属性值可以是：left、right、center（在当前容器的中间）、justify
    text-transform: lowercase; 单词的字体大小写。属性值可以是：uppercase（单词大写）、lowercase（单词小写）、capitalize（每个单词的首字母大写）

列表属性:
    list-style ;  /*列表样式*/
    list-style-image:url(images/2.gif) ;  /*列表项前设置为图片*/
    list-style-type:type ;  /*设置列表项标记的类型，如circle、square、decimal等*/
    list-style-position:inside ;  /*列表项标记的位置。inside表示在文本内，outside表示在文本外*/

overflow属性：超出范围的内容要怎么处理
    overflow : visible ;  /*默认值，内容不会被修剪，会呈现在元素框之外*/
    overflow : hidden ;   /*内容会被修剪，并且其余内容是不可见的*/
    overflow : scroll ;   /*内容会被修剪，但是浏览器会显示滚动条以便查看其余内容*/
    overflow : auto ;     /*如果内容被修剪，则浏览器会显示滚动条以便查看其余内容*/

鼠标的属性cursor有以下几个属性值：
    auto：默认值。浏览器根据当前情况自动确定鼠标光标类型。
    pointer：IE6.0，竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。
    hand：和pointer的作用一样：竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。

滤镜:
    <img src="3.jpg" style="filter:gray()">; /*灰度滤镜*/

css2.1 中，常见的背景属性有以下几种：（经常用到，要记住）
    background-color:#ff99ff/单词/rgb/rgba/hsla(色调,饱和度,亮度,透明度); 设置元素的背景颜色。
    background-image:url(images/2.gif); 将图像设置为背景。
    background-repeat: no-repeat; 设置背景图片是否重复及如何重复，默认平铺满。（重要）
        no-repeat不要平铺；
        repeat-x横向平铺；
        repeat-y纵向平铺。
    background-position:center top/100px 200px向右向下; 设置背景图片在当前容器中的位置。
    background-attachment:scroll; 设置背景图片是否跟着滚动条一起移动。 属性值可以是：scroll（与fixed属性相反，默认属性）、fixed（背景就会被固定住，不会被滚动条滚走）。
    background: blue url(images/wuyifan.jpg) no-repeat 100px 100px; 将上面的多个属性写在一个声明中。

CSS3 中，新增了一些background属性：
    background-origin 控制背景从什么地方开始显示。
        /* 从 padding-box 内边距开始显示背景图 */
	    background-origin: padding-box;           //默认值
        /* 从 border-box 边框开始显示背景图  */
        background-origin: border-box;
        /* 从 content-box 内容区域开始显示背景图  */
        background-origin: content-box;
    background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框下面
        background-clip: content-box; 超出的部分，将裁剪掉。属性值可以是：
        border-box ;超出 border-box 的部分，将裁剪掉
        padding-box ;超出 padding-box 的部分，将裁剪掉
        content-box ;超出 content-box 的部分，将裁剪掉
    background-size 调整尺寸
        /* 宽、高的具体数值 */
        background-size: 500px 500px;
        /* 宽高的百分比（相对于容器的大小） */
        background-size: 50% 50%;   // 如果两个属性值相同，可以简写成：background-size: 50%;
        background-size: 100% auto;  //这个属性可以自己试验一下。
        /* cover：图片始终填充满容器，且保证长宽比不变。图片如果有超出部分，则超出部分会被隐藏。 */
        background-size: cover;
        /* contain：将图片完整地显示在容器中，且保证长宽比不变。可能会导致容器的部分区域为空白。  */
        background-size: contain;
    多重背景
        background: url(images/bg1.png) no-repeat left top,
            url(images/bg2.png) no-repeat right top,
            url(images/bg3.png) no-repeat right bottom,
            url(images/bg4.png) no-repeat left bottom,
            url(images/bg5.png) no-repeat center;

颜色线性渐变
    background-image: linear-gradient(方向, 起始颜色, 终止颜色);
    background-image: linear-gradient(to right, yellow, green);
颜色径向渐变
    background-image: radial-gradient(辐射的半径大小, 中心的位置, 起始颜色, 终止颜色);
	background-image: radial-gradient(100px at center,yellow ,green);

clip-path：裁剪出元素的部分区域做展示
    clip-path属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。
    虽然clip-path不是背景属性，但这个属性非常强大，但往往会结合背景属性一起使用，达到一些效果。
    clip-path: circle(50% at 50% 50%);  /*圆形裁剪区域*/
    clip-path: ellipse(50% 30% at 50% 50%);  /*椭圆形裁剪区域*/

CSS 的书写方式有三种：

    行内样式：在某个特定的标签里采用 style 属性。范围只针对此标签。
    内嵌样式（内联样式）：在页面的 head 标签里里采用<style>标签。范围针对此页面。
    外链样式：引入外部样式表 CSS 文件。这种引入方式又分为两种：
        采用<link>标签。例如：<link rel = "stylesheet" type = "text/css" href = "a.css"></link>
        采用 import 导入，必须写在<style>标签中。然后用类似于@import url(a.css) ;这种方式导入。
            <link>标签的 rel 属性：。其属性值有以下两种：
                stylesheet：定义的样式表
                alternate stylesheet：候选的样式表

CSS 的选择器
    CSS 选择器：就是指定 CSS 要作用的标签，那个标签的名称就是选择器。意为：选择哪个容器。
    CSS 的选择器分为两大类：基本选择器和扩展选择器。
        基本选择器：
            标签选择器：针对一类标签,直接写标签名称表示
            ID 选择器：针对某一个特定的标签使用,用#加ID名称表示
            类选择器：针对你想要的所有标签使用,用.加类名称表示,同一个标签可以使用多个类选择器。用空格隔开,class="teshu  zhongyao"
            通用选择器（通配符）：针对所有的标签都适用（不建议使用）,用*表示
        高级选择器：
            后代选择器：用空格隔开,对于E F这种格式，表示所有属于 E 元素后代的 F 元素，有这个样式。空格就表示后代。
                后代选择器，就是一种平衡：共性、特性的平衡。当要把某一个部分的所有的什么，进行样式改变，就要想到后代选择器。
            交集选择器：选择器之间紧密相连
                交集选择器：定义的时候紧密相连
                定义交集选择器的时候，两个选择器之间紧密相连。一般是以标签名开头，比如div.haha，再比如p.special。
                如果后一个选择器是类选择器，则写为div.special；如果后一个选择器 id 选择器，则写为div#special。
            并集选择器（分组选择器）：用逗号隔开,三种基本选择器都可以放进来。
            伪类选择器:同一个标签，根据其不同的种状态，有不同的样式。这就叫做“伪类”。伪类用冒号来表示。
                比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。
                    伪类选择器分为两种。
                        （1）静态伪类：只能用于超链接的样式。如下：
                        :link 超链接点击之前
                        :visited 链接被访问过之后
                        PS：以上两种样式，只能用于超链接。

                            超链接a标签
                                #超链接的四种状态
                                a标签有4种伪类（即对应四种状态），要求背诵。如下：

                                :link “链接”：超链接点击之前
                                :visited “访问过的”：链接被访问过之后
                                :hover “悬停”：鼠标放到标签上的时候
                                :active “激活”： 鼠标点击标签，但是不松手时。
                                对应的代码如下：
                                <style type="text/css">
                                    /*让超链接点击之前是红色*/
                                    a:link{
                                        color:red;
                                    }

                                    /*让超链接点击之后是绿色*/
                                    a:visited{
                                        color:orange;
                                    }

                                    /*鼠标悬停，放到标签上的时候*/
                                    a:hover{
                                        color:green;
                                    }

                                    /*鼠标点击链接，但是不松手的时候*/
                                    a:active{
                                        color:black;
                                    }
                                </style>
                                记住，在css中，这四种状态必须按照固定的顺序写：
                                a:link 、a:visited 、a:hover 、a:active
                                问：既然a{}定义了超链的属性，和a:link{}定义了超链点击之前的属性，那这两个有啥区别呢？
                                答：
                                a{}和a:link{}的区别：
                                a{}定义的样式针对所有的超链接(包括锚点)
                                a:link{}定义的样式针对所有写了href属性的超链接(不包括锚点)
                                超链接a标签在使用的时候，比较难。因为不仅仅要控制a这个盒子，也要控制它的伪类。
                                我们一定要将a标签写在前面，将:link、:visited、:hover、:active这些伪类写在后面。
                                
                                a:link、a:visited都是可以省略的，简写在a标签里面。也就是说，a标签涵盖了link、visited的状态（前提是都具有了相同的属性）。

                        （2）动态伪类：针对所有标签都适用的样式。如下：
                        :hover “悬停”：鼠标放到标签上的时候
                        :active “激活”： 鼠标点击标签，但是不松手时。
                        :focus 是某个标签获得焦点时的样式（比如某个输入框获得焦点）

选择器兼容性问题:
    1.子代选择器，用符号>表示
        IE7 开始兼容，IE6 不兼容。
        div > p {
            color: red;
        }
        div 的儿子 p。和 div 的后代 p 的截然不同。
    2.序选择器
        IE8 开始兼容；IE6、7 都不兼容
        设置无序列表<ul>中的第一个<li>为红色：
            <style type="text/css">
                ul li:first-child {
                    color: red;
                }
        </style>
        设置无序列表<ul>中的最后一个<li>为红色：
            ul li:last-child {
                color: blue;
            }
    3.下一个兄弟选择器
        IE7 开始兼容，IE6 不兼容。
        +表示选择下一个兄弟
            <style type="text/css">
                h3 + p {
                    color: red;
                }
            </style>
        上方的选择器意思是：选择的是 h3 元素后面紧挨着的第一个兄弟。


css的继承性
    关于文字样式的属性，都具有继承性。这些属性包括：color、 text-开头的、line-开头的、font-开头的。
    关于盒子、定位、布局的属性，都不能继承。
css的层叠性
    层叠性：计算权重
    层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！
    当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重：
    id 选择器
    类选择器、属性选择器、伪类选择器
    标签选择器、伪元素选择器
    因为对于相同方式的样式表，其选择器排序的优先级为：ID选择器 > 类选择器 > 标签选择器
    如果不能直接选中某个元素，通过继承性影响的话，那么权重是0。
    如果我们想使用某个权重小的样式，只需要给标签选择器的加一个!important标记，此时其权重为无穷大
        (1)!important提升的是一个属性，而不是一个选择器
        (2)!important无法提升继承的权重，该是0还是0
        (3)!important不影响就近原则


css盒模型:
    盒子模型，英文即box model。无论是div、span、还是a都是盒子。
    盒子中的区域
        一个盒子中主要的属性就5个：width、height、padding、border、margin。如下：
        width和height：内容的宽度、高度（不是盒子的宽度、高度）。
        padding：内边距。
        border：边框。
        margin：外边距。
    CSS盒模型和IE盒模型的区别：
    在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。
    IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。
    注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分。

padding有四个方向
    padding是4个方向的，所以我们能够分别描述4个方向的padding。
    方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。
    小属性的写法：
        padding-top: 30px;
        padding-right: 20px;
        padding-bottom: 40px;
        padding-left: 100px;
    综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的）
    padding:30px 20px 40px 100px;
    如果写了四个值，则顺序为：上、右、下、左。
    如果只写了三个值，则顺序为：上、右和左、下。
    如果只写了两个值，则顺序为：上和下、左和右。

border
    border就是边框。边框有三个要素：像素（粗细）、线型、颜色。
    颜色如果不写，默认是黑色。另外两个属性如果不写，则无法显示边框。
    border属性是能够被拆开的，有两大种拆开的方式：
        （1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的）
        （2）按方向拆开：border-top、border-right、border-bottom、border-left。
    利用 border 属性画一个三角形:
        .div1{
            width: 0;
            height: 0;
            border-top: 30px solid red;
            /* 通过改变 border-left 和 border-right 中的像素值，来改变三角形的形状 */
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
                }

标准文档流
    宏观地讲，我们的web页面和photoshop等设计软件有本质的区别：web页面的制作，是个“流”，必须从上而下，像“织毛衣”。而设计软件，想往哪里画个东西，都能画。
    标准文档流的特性
        （1）空白折叠现象：
        无论多少个空格、换行、tab，都会折叠为一个空格。
        （2）高矮不齐，底边对齐.
        （3）自动换行，一行写不满，换行写。

行内元素和块级元素的区别：（非常重要）
    行内元素：
        与其他行内元素并排；
        不能设置宽、高。默认的宽度，就是文字的宽度。
    块级元素：
        霸占一行，不能与其他任何元素并列；
        能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。

行内元素和块级元素的分类：
    在以前的HTML知识中，我们已经将标签分过类，当时分为了：文本级、容器级。
    从HTML的角度来讲，标签分为：
        文本级标签：p、span、a、b、i、u、em。
        容器级标签：div、h系列、li、dt、dd。
            PS：为甚么说p是文本级标签呢？因为p里面只能放文字&图片&表单元素，p里面不能放h和ul，p里面也不能放p。
    现在，从CSS的角度讲，CSS的分类和上面的很像，就p不一样：
        行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级，但是是个块级元素。
        块级元素：所有的容器级标签都是块级元素，还有p标签。

行内元素和块级元素的相互转换
    我们可以通过display属性将块级元素和行内元素进行相互转换。display即“显示模式”。
        块级元素可以转换为行内元素：
        一旦，给一个块级元素（比如div）设置：
            display: inline;
        那么，这个标签将立即变为行内元素，此时它和一个span无异。inline就是“行内”。也就是说：
        此时这个div不能设置宽度、高度；
        此时这个div可以和别人并排了。
    行内元素转换为块级元素：
        同样的道理，一旦给一个行内元素（比如span）设置：
            display: block;
        那么，这个标签将立即变为块级元素，此时它和一个div无异。block”是“块”的意思。也就是说：
        此时这个span能够设置宽度、高度
        此时这个span必须霸占一行了，别人无法和他并排
        如果不设置宽度，将撑满父亲

css中一共有三种手段，使一个元素脱离标准文档流：
    （1）浮动
    （2）绝对定位
    （3）固定定位

浮动（float属性）:
    float属性的作用：让一个元素脱离标准文档流，从而可以让其他元素环绕它排列。
    float属性的取值：
        left：向左浮动
        right：向右浮动
        none：不浮动，默认值
    清除浮动（clear属性）:
        clear属性的作用：阻止元素环绕浮动元素排列，从而使该元素显示在浮动元素的下方。
        clear属性的取值：
            left：阻止元素环绕左浮动元素排列
            right：阻止元素环绕右浮动元素排列
            both：阻止元素环绕所有浮动元素排列
            none：默认值，允许元素环绕浮动元素排列
    性质:
        性质1：浮动的元素脱离标准文档流
        性质2：浮动的元素互相贴靠
        性质3：浮动的元素有“字围”效果
            标准流中的文字不会被浮动的盒子遮挡住。（文字就像水一样）
            关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。
        性质4：收缩
            收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。

清除浮动:
    方法1：给浮动元素的祖先元素加高度
        如果一个元素要浮动，那么它的祖先元素一定要有高度。
            有高度的盒子，才能关住浮动。（记住这句过来人的经验之语）
            只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。
    方法2：clear:both;
        网页制作中，高度height其实很少出现。为什么？因为能被内容撑高！也就是说，刚刚我们讲解的方法1，工作中用得很少。
        那么，能不能不写height，也把浮动清除了呢？也让浮动之间，互不影响呢？
        这个时候，我们可以使用clear:both;这个属性。
        clear就是清除，both指的是左浮动、右浮动都要清除。clear:both的意思就是：不允许左侧和右侧有浮动对象。
        这种方法有一个非常大的、致命的问题，它所在的标签，margin属性失效了。读者可以试试看。
        margin失效的本质原因是：上图中的box1和box2，高度为零。
    方法3：隔墙法
        为了防止第二个div贴靠到第二个div，我们可以在这两个div中间用一个新的div隔开，然后给这个新的div设置clear: both;属性；同时，既然这个新的div无法设置margin属性，我们可以给它设置height，以达到margin的效果（曲线救国）。这便是隔墙法。
        内墙法:
            公式:两个p都浮动,所以父亲div不能被撑出高，如果在家里修一堵墙，就能让父亲div撑出高。此时div可以自适应内容。
            方法:在浮动元素的后面，添加一个新的空div,并且给这个div设置clear:both;
        与外墙法相比，内墙法的优势（本质区别）在于：内墙法可以给它所在的家撑出宽度（让box1有高）。即：box1的高度可以自适应内容。
        而外墙法，虽然一道墙可以把两个div隔开，但是这两个div没有高，也就是说，无法wrap_content。
    方法4：overflow:hidden;
        我们可以使用如下属性：
        overflow:hidden;
        overflow即“溢出”， hidden即“隐藏”。这个属性的意思是“溢出隐藏”。顾名思义：所有溢出边框的内容，都要隐藏掉。
        上图显示，overflow:hidden;的本意是清除溢出到盒子外面的文字。但是，前端开发工程师发现了，它能做偏方。如下：
        一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上overflow:hidden; 那么，父亲就能被儿子撑出高了。这是一个偏方。
    浮动清除的总结:
        浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。
            #1、加高法
            工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。
            2、clear:both;法
            最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。
            浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。
            #3、隔墙法
            在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。 墙用自己的身体当做了间隙。
            我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动根据自己的儿子撑出高度，我们就要想一些“小伎俩”。
            内墙法：
            内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。
            #4、overflow:hidden;
            这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。 我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的偏方。 并且,overflow:hidden;能够让margin生效。

浏览器的兼容性问题:
    兼容性1（微型盒子）
        兼容性的第一条：IE6不支持小于12px的盒子，任何小于12px的盒子，在IE6中看都大。即：IE 6不支持微型盒子。
        举个例子。我们设置一个height为 5px 、宽度为 200px的盒子，看下在IE 8和 IE 6中的显示效果：
        解决办法很简单，就是将盒子的字号大小，设置为小于盒子的高，比如，如果盒子的高为5px，那就把font-size设置为0px(0px < 5px)。
        height: 5px;
        _font-size: 0px;
    
    我们现在介绍一下浏览器hack。hack就是“黑客”，就是使用浏览器提供的后门，针对某一种浏览器做兼容。
    IE6留了一个后门：只要给css属性之前，加上下划线，这个属性就是IE6的专有属性。
    比如说，我们给背景颜色这个属性加上下划线，就变成了_background-color: green;。
    于是乎，为了解决微型盒子（即height小于12px）的问题，正确写法：（注意不要忘记下划线）
    height: 10px;
    _font-size:0;
    兼容性2
    兼容性的第二条：**IE6不支持用overflow:hidden;来清除浮动。
        解决办法，以毒攻毒。追加一条：
        _zoom:1;
        完整写法：
        overflow: hidden;
        _zoom:1;
        实际上，_zoom:1;能够触发浏览器hasLayout机制。这个机制，不要深究了，因为只有IE6有。我们只需要让IE6好用，具体的实现机制，可以自行查阅。
        需要强调的是，overflow:hidden;的本意，就是让溢出盒子的border的内容隐藏，这个功能是IE6兼容的。不兼容的是overflow:hidden;清除浮动的时候。

    总结：
        我们刚才学习的两个IE6的兼容问题，都是通过多写一条hack来解决的，这个我们称为伴生属性，即两个属性，要写一起写。
        属性1：
        height:6px;
        _font-size:0;
        属性2：
        overflow:hidden;
        _zoom:1;

margin相关:
    margin塌陷/margin重叠
    标准文档流中，竖直方向的margin不叠加，取较大的值**作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。
    如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有塌陷现象的。
    盒子居中margin:0 auto;
    margin的值可以为auto，表示自动。当left、right两个方向都是auto的时候，盒子居中了：
        margin-left: auto;
        margin-right: auto;
    盒子居中的简写为：
        margin:0 auto;
    对上方代码的理解：上下的margin为0，左右的margin都尽可能的大，于是就居中了。
    注意：
        （1）只有标准流的盒子，才能使用margin:0 auto;居中。也就是说，当一个盒子浮动了、绝对定位了、固定定位了，都不能使用margin:0 auto;
        （2）使用margin:0 auto;的盒子，必须有width，有明确的width。（可以这样理解，如果没有明确的width，那么它的width就是霸占整行，没有意义）
        （3）margin:0 auto;是让盒子居中，不是让盒子里的文本居中。文本的居中，要使用text-align:center;
    对上面的第三条总结一下：（非常重要）
        margin:0 auto;    //让这个div自己在大容器中的水平方向上居中。
        text-align: center;  //让这个div内部的文本居中。
    顺便普及一下知识，text-align还有：
        text-align:left;     //没啥用，因为默认居左
        text-align:right;    //文本居右
    margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。
    所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。

关于margin的IE6兼容问题
    IE6的双倍margin的bug：
    当出现连续浮动的元素，携带与浮动方向相同的margin时，队首的元素，会双倍marign。
    解决方案：
        （1）使浮动的方向和margin的方向，相反。
        所以，你就会发现，我们特别喜欢，浮动的方向和margin的方向相反。并且，前端开发工程师，把这个当做习惯了。
            float: left;
            margin-right: 40px;
        （2）使用hack：（没必要，别惯着这个IE6）
            单独给队首的元素，写一个一半的margin：
            <li class="no1"></li>
            ul li.no1{
                _margin-left:20px;
            }
            PS：双倍margin的问题，面试经常问哦。

    IE6的3px bug：
        当一个元素浮动，并且设置了border或者padding时，IE6会多出3px的空间。
        解决办法：不用管，因为根本就不允许用儿子踹父亲（即描述父子之间的距离，请用padding，而不是margin）。所以，如果你出现了3px bug，说明你的代码不标准。
        IE6，千万不要跟他死坑、较劲，它不配。 格调要高，我们讲IE6的兼容性问题，就是为了增加面试的成功率，不是为了成为IE6的专家。

Fireworks和others
    #Fireworks
    fireworks是Adobe公司的一个设计软件。功能非常多，我们以后用啥讲啥。Fireworks的默认文件格式是png。
    标尺的快捷键：Ctrl + Alt+ R
    #others
    首行缩进两个汉字：
    text-indent: 2em;
    上方属性中，单位比较奇怪，叫做em，em就是汉字的一个宽度。indent的意思是缩进.

CSS的定位属性有三种，分别是绝对定位、相对定位、固定定位。
	position: absolute;  <!-- 绝对定位 -->
	position: relative;  <!-- 相对定位 -->
	position: fixed;     <!-- 固定定位 -->

    相对定位
        相对定位：让元素相对于自己原来的位置，进行位置调整（可用于盒子的位置微调）。
        我们之前学习的背景属性中，是通过如下格式：
            background-position:向右偏移量 向下偏移量;
        但这回的定位属性，是通过如下格式：
            position: relative;/*相对定位：相对于自己原来的位置*/
			left: 50px;/*横坐标：正值表示向右偏移，负值表示向左偏移*/
			top: 50px;/*纵坐标：正值表示向下偏移，负值表示向上偏移*/
    相对定位不脱标
        相对定位：不脱标，老家留坑，别人不会把它的位置挤走。
        也就是说，相对定位的真实位置还在老家，只不过影子出去了，可以到处飘。
        #相对定位的用途
        如果想做“压盖”效果（把一个div放到另一个div之上），我们一般不用相对定位来做。相对定位，就两个作用：
        （1）微调元素
        （2）做绝对定位的参考，子绝父相
        #相对定位的定位值
        left：盒子右移
        right：盒子左移
        top：盒子下移
        bottom：盒子上移
        PS：负数表示相反的方向.
    绝对定位
        绝对定位：定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。
        格式举例如下：
            position: absolute;  /*绝对定位*/
            left: 10px;  /*横坐标*/
            top/bottom: 20px;  /*纵坐标*/
        #绝对定位脱标
            绝对定位的盒子脱离了标准文档流。
            所以，所有的标准文档流的性质，绝对定位之后都不遵守了。
            绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要display:block就可以设置宽、高了。
        绝对定位的参考点（重要）
            （1）如果用top描述，那么参考点就是页面的左上角，而不是浏览器的左上角。      
            （2）如果用bottom描述，那么参考点就是浏览器首屏窗口尺寸（好好理解“首屏”二字），对应的页面的左下角：
        以盒子为参考点
            一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。
            以下几点需要注意。
                （1） 要听最近的已经定位的祖先元素的，不一定是父亲，可能是爷爷：
                        <div class="box1">        相对定位
                            <div class="box2">    没有定位
                                <p></p>           绝对定位，将以box1为参考，因为box2没有定位，box1就是最近的父辈元素
                            </div>
                        </div>
                再比如：
                        <div class="box1">        相对定位
                            <div class="box2">    相对定位
                                <p></p>           绝对定位，将以box2为参考，因为box2是自己最近的父辈元素
                            </div>
                        </div>
                （2）不一定是相对定位，任何定位，都可以作为儿子的参考点：
                    子绝父绝、子绝父相、子绝父固，都是可以给儿子定位的。但是在工程上，如果子绝、父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。
                    工程应用：
                    “子绝父相”有意义：这样可以保证父亲没有脱标，儿子脱标在父亲的范围里面移动。于是，工程上经常这样做：
                    父亲浮动，设置相对定位（零偏移），然后让儿子绝对定位一定的距离。
                （3）绝对定位的儿子，无视参考的那个盒子的padding：
                    工程应用：
                    绝对定位非常适合用来做“压盖”效果。
            让绝对定位中的盒子在父亲里居中
                我们知道，如果想让一个标准流中的盒子在父亲里居中（水平方向看），可以将其设置margin: 0 auto属性。
                可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做：
                    div {
                        width: 600px;
                        height: 60px;
                        position: absolute;  绝对定位的盒子
                        left: 50%;           首先，让左边线居中
                        top: 0;
                        margin-left: -300px;  然后，向左移动宽度（600px）的一半
                    }
                如上方代码所示，我们先让这个宽度为600px的盒子，左边线居中，然后向左移动宽度（600px）的一半，就达到效果了。
                我们可以总结成一个公式：
                left:50%; margin-left:负的宽度的一半

固定定位
    固定定位：就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。
    备注：IE6不兼容。
        用途1：网页右下角的“返回到顶部”
            比如我们经常看到的网页右下角显示的“返回到顶部”，就可以固定定位。
        用途2：制作网页的导航栏
            我们经常能看到固定在网页顶端的导航条，可以用固定定位来做。
            需要注意的是，假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top。

z-index属性：
    z-index属性：表示谁压着谁。数值大的压盖住数值小的。
    有如下特性：
        （1）属性值大的位于上层，属性值小的位于下层。
        （2）z-index值没有单位，就是一个正整数。默认的z-index值是0。
        （3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。
        （4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。而浮动的元素不能用。
        （5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。
    z-index属性的应用还是很广泛的。当好几个已定位的标签出现覆盖的现象时，我们可以用这个z-index属性决定，谁处于最上方。也就是层级的应用。
        层级：
        （1）必须有定位（除去static）
        （2）用z-index来控制层级数。

